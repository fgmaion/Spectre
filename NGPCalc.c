int NGPCalc(){
    // ApplyJenkins();
    
    // CountGalaxies();
    
    cic_Assignment(); 
    
    overdensity_varyingSelection();
    
    printSurveyDetails();
    
    return 0;
}


int NGPCalcCube(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
    // ApplyJenkins();
    
    CountGalaxiesCube(xCoor, yCoor, zCoor, objectNumber);
    
    // cic_Assignment(xCoor, yCoor, zCoor, objectNumber);
    
    // overdensity_volumeLimitedTracer(objectNumber);    
    
    // printSurveyDetails();
    
    return 0;
}


int GaussCube(){
    sprintf(filepath, "%s/Data/HODCube/GaussianRandomField_256.txt", root_dir);

    inputfile = fopen(filepath, "r");
    
    float* input;
    
    input = malloc(256*256*256*sizeof(float));
    
    for(k=0; k<256; k++){
        for(j=0; j<256; j++){
            for(i=0; i<256; i++){
                Index        = k*n1*n2 + j*n2 + i; 
                
                fscanf(inputfile, "%f \n", &input[Index]);
            }
        }
    }

    fclose(inputfile);
    
    for(j=0; j<256*256*256; j++) densityArray[j] = (double) input[j];
    
    /*
    sprintf(filepath, "%s/Data/HODCube/GaussianRandomField_256.dat", root_dir);
    
    output = fopen(filepath, "wb");
    
    for(j=0; j<256*256*256; j++) fprintf(output, "%e \n");
    
    fclose(output);
    */
    
    return 0;
}


int boxCoordinates(double xCoor[], double yCoor[], double zCoor[], int rowNumber){
    xlabel                  = (int) floor((xCoor[rowNumber] - AxisLimsArray[0][0])/CellSize);    
    ylabel                  = (int) floor((yCoor[rowNumber] - AxisLimsArray[0][1])/CellSize);
    zlabel                  = (int) floor((zCoor[rowNumber] - AxisLimsArray[0][2])/CellSize);
    
    boxlabel                = (int)                        xlabel + n2*ylabel + n2*n1*zlabel;

    return boxlabel;
}


int cic_Assignment(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
    for(j=0; j<objectNumber; j++){
        // if(Acceptanceflag[j] == true){
            cic_assign(xCoor[j], yCoor[j], zCoor[j], CellSize, densityArray, 1.0);
        // }
    }
    
    return 0;
}


int CountGalaxies(){
    for(j=0; j<Vipers_Num; j++){
        boxlabel = boxCoordinates(xCoor, yCoor, zCoor, j);
		            
        if(Acceptanceflag[j] == true){    
            densityArray[boxlabel]     += 1;
		    meanCellRedshift[boxlabel] += zUtilized[j];
        }
    }
    
    
    for(j=0; j<n0*n1*n2; j++){
        if(densityArray[j] > 0.0){
	        // Currently densityArray contains solely galaxy counts per cell.
            meanCellRedshift[j] /= densityArray[j];
        }
    }
    
    // TotalZADEWeight = SumDoubleArray(densityArray, n0*n1*n2);
    
    return 0;
}


int CountGalaxiesCube(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
     // Impose redshift  cuts for a VIPERS like survey between 0.7 and 0.9.  Window fn defined by booldensity as generated by randoms.                                                                                                                     
    for(j=0; j<objectNumber; j++){
        boxlabel = boxCoordinates(xCoor, yCoor, zCoor, j);

        densityArray[boxlabel] += 1;
    }
    
    // TotalZADEWeight = SumDoubleArray(densityArray, n0*n1*n2);                                                                 
 
 return 0;
}


double CubeMeanNumberDensity(double chi){
    // Galaxies in cube/comoving volume. 
    
    return Vipers_Num/TotalVolume; 
}


int overdensity_volumeLimitedTracer(int objectNumber){
    // The true density field. 
    // printf("\nMax counts: %f", arrayMax(densityArray, n0*n1*n2));

    for(j=0; j<n0*n1*n2; j++)  densityArray[j] /= CellVolume*(objectNumber/TotalVolume);

    for(j=0; j<n0*n1*n2; j++)  densityArray[j] -= 1.0;

    return 0;
}


int overdensity_varyingSelection(){    
    fkpShotNoiseCorr = 0.0;

    for(k=0; k<n0; k++){
        for(j=0; j<n1; j++){ 
            for(i=0; i<n2; i++){
                Index                         = k*n1*n2 + j*n2 + i; 
                
                Chi                           = Cell_chiVIPERSsystem[Index];

		        densityArray[Index]          /= CellVolume*(*pt2nz)(Chi);
                
                densityArray[Index]          -=  1.0;
            }
        }
    }
    
    // printf("\n\nFKP shot noise P(k) expectation:            %e", fkpShotNoiseCorr);
    // printf("\nFKP unweighted shot noise P(k) expectation:   %e", 1./TotalZADEWeight);

    return 0;
}


int printSurveyDetails(){
    printf("\n\nSurvey type:  %s", surveyType);
    printf("\nChi limits:              %f to %f", LowerChiLimit, UpperChiLimit);
    printf("\nright ascension limits:  %f to %f", UpperRAlimit, LowerRAlimit);
    printf("\ndeclination limits:      %f to %f", UpperDecLimit, LowerDecLimit);
    printf("\nCell volume:                   %f.",        CellVolume); 
    printf("\n\nTotal volume:            %e", TotalVolume);
    printf("\nTotal surveyed volume:   %e", TotalSurveyedVolume);

    printf("\n\nfundamental x mode:  %f", kIntervalx);
    printf("\nfundamental y mode:  %f", kIntervaly);
    printf("\nfundamental z mode:  %f", kIntervalz);
    
    return 0;
}
