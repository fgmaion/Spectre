int NGPCalc(){
    ApplyJenkins();
    
    CountGalaxies();
    
    overdensity_ImperfectSelectionTracer();
    
    printSurveyDetails();
    return 0;
}


int NGPCalcCube(){
    ApplyJenkins();
    
    CountGalaxiesCube();
    
    overdensity_volumeLimitedTracer();    
    
    printSurveyDetails();
    return 0;
}


int boxCoordinates(int rowNumber){
    xlabel                  = (int) floor((xCoor[rowNumber] - AxisLimsArray[0][0])/CellSize);
    ylabel                  = (int) floor((yCoor[rowNumber] - AxisLimsArray[0][1])/CellSize);
    zlabel                  = (int) floor((zCoor[rowNumber] - AxisLimsArray[0][2])/CellSize);
    boxlabel                = (int)                        xlabel + n2*ylabel + n2*n1*zlabel;

    return boxlabel;
}


int CountGalaxies(){
    // Impose redshift and absolute magnitude cuts for a volume limited, VIPERS like survey between 0.7 and 0.9.  Window fn defined by booldensity as generated by randoms.

    for(j=0; j<Vipers_Num; j++){
        boxlabel = boxCoordinates(j);
            
        if((zcos[j] > redshiftLowLimit) && (zcos[j] < redshiftHiLimit) && (M_B[j] < absMagCut) && (booldensity[boxlabel] > 0.1)){ 
		    densityArray[boxlabel] += 1;
		}
    }

    TotalZADEWeight = SumDoubleArray(densityArray);

    return 0;
}


int CountGalaxiesCube(){
    // Cubic run, perhaps to which a window fn. is to be applied. 

    for(j=0; j<Vipers_Num; j++){
        boxlabel = boxCoordinates(j);

        if(booldensity[boxlabel] > 0.1){ 
		    densityArray[boxlabel] += 1;
	    }
    }
    
    TotalZADEWeight = SumDoubleArray(densityArray);
    
    return 0;
}


int overdensity_volumeLimitedTracer(){
    MeanNumberDensity = TotalZADEWeight/TotalSurveyedVolume;

    for(j=0; j<n0*n1*n2; j++)  densityArray[j] /= CellVolume*MeanNumberDensity;
    for(j=0; j<n0*n1*n2; j++)  densityArray[j] -= 1.0;

    return 0;
}


int overdensity_ImperfectSelectionTracer(){
    MeanNumberDensity = TotalZADEWeight/TotalSurveyedVolume;

    printf("\nNumber density interpolated at z=0.8:  %f", interp_nz(interp_comovingDistance(0.8)));
    
    fkpShotNoiseCorr = 0.0;

    for(k=0; k<n0; k++){
        for(j=0; j<n1; j++){ 
            for(i=0; i<n2; i++){
                Index                         = k*n1*n2 + j*n2 + i; 
            
                Chi                           = CellSize*pow(k*k + j*j + i*i, 0.5);
                
                if(densityArray[Index] > 0){
                    fkpShotNoiseCorr         += pow(TotalFKPweight, -2.)*pow(CellVolume, -1.)*pow(FKPweights[Index], 2.)/interp_nz(Chi);
                }
    
                densityArray[Index]          /= CellVolume*interp_nz(Chi);
                densityArray[Index]          -= 1.0;
            }
        }
    }
    
    printf("\n\nFKP shot noise P(k) expectation:            %e", fkpShotNoiseCorr);
    printf("\nFKP unweighted shot noise P(k) expectation:   %e", 1./TotalZADEWeight);

    return 0;
}


int printSurveyDetails(){
    printf("\n\nTotal ZADE weight: %e.", TotalZADEWeight);
    printf("\nCell volume:  %f.",        CellVolume); 
    printf("\nMean number density:  %f", MeanNumberDensity);    
    printf("\n\nNon-empty cells:  %e  [n0*n1*n2]", SumOfBoolDensity/(n0*n1*n2));
    printf("\n\nTotal surveyed volume: %e    [TotalVolume]", (float) TotalSurveyedVolume/TotalVolume);
    return 0;
}


double SumDoubleArray(double array[]){
    double Interim = 0.0;

    for(j=0; j<n0*n1*n2; j++){
        Interim += array[j];
    }

    return Interim;
}
