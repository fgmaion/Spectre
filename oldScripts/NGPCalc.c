int NGPCalc(){
    // ApplyJenkins();
    
    // cic_Assignment(); 
    
    // overdensity_varyingSelection();
    
    // printSurveyDetails();
    
    return 0;
}


int NGPCalcCube(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
    // ApplyJenkins();
    
    CountGalaxiesCube(xCoor, yCoor, zCoor, objectNumber);
    
    // cic_Assignment(xCoor, yCoor, zCoor, objectNumber);
    
    // overdensity_volumeLimitedTracer(objectNumber);    
    
    // printSurveyDetails();
    
    return 0;
}


int GaussCube(){
    sprintf(filepath, "%s/Data/HODCube/GaussianRandomField_256.txt", root_dir);

    inputfile = fopen(filepath, "r");
    
    float* input;
    
    input = malloc(256*256*256*sizeof(float));
    
    for(k=0; k<256; k++){
        for(j=0; j<256; j++){
            for(i=0; i<256; i++){
                Index        = k*n1*n2 + j*n2 + i; 
                
                fscanf(inputfile, "%f \n", &input[Index]);
            }
        }
    }

    fclose(inputfile);
    
    for(j=0; j<256*256*256; j++) densityArray[j] = (double) input[j];
    
    /*
    sprintf(filepath, "%s/Data/HODCube/GaussianRandomField_256.dat", root_dir);
    
    output = fopen(filepath, "wb");
    
    for(j=0; j<256*256*256; j++) fprintf(output, "%e \n");
    
    fclose(output);
    */
    
    return 0;
}


int cic_Assignment(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
    for(j=0; j<objectNumber; j++){
        // if(Acceptanceflag[j] == true){
            cic_assign(xCoor[j], yCoor[j], zCoor[j], CellSize, densityArray, 1.0);
        // }
    }
    
    return 0;
}


int CountGalaxiesCube(double xCoor[], double yCoor[], double zCoor[], int objectNumber){
     // Impose redshift  cuts for a VIPERS like survey between 0.7 and 0.9.  Window fn defined by booldensity as generated by randoms.                                                                                                                     
    for(j=0; j<objectNumber; j++){
        boxlabel = boxCoordinates(xCoor, yCoor, zCoor, j);

        densityArray[boxlabel] += 1;
    }
    
    // TotalZADEWeight = SumDoubleArray(densityArray, n0*n1*n2);                                                                 
 
 return 0;
}


int overdensity_volumeLimitedTracer(int objectNumber){
    // The true density field. 
    // printf("\nMax counts: %f", arrayMax(densityArray, n0*n1*n2));

    for(j=0; j<n0*n1*n2; j++)  densityArray[j] /= CellVolume*(objectNumber/TotalVolume);

    for(j=0; j<n0*n1*n2; j++)  densityArray[j] -= 1.0;

    return 0;
}


int overdensity_varyingSelection(){    
    fkpShotNoiseCorr = 0.0;

    for(k=0; k<n0; k++){
        for(j=0; j<n1; j++){ 
            for(i=0; i<n2; i++){
                Index                         = k*n1*n2 + j*n2 + i; 
                
                Chi                           = Cell_chiVIPERSsystem[Index];

		        densityArray[Index]          /= CellVolume*(*pt2nz)(Chi);
                
                densityArray[Index]          -=  1.0;
            }
        }
    }
    
    // printf("\n\nFKP shot noise P(k) expectation:            %e", fkpShotNoiseCorr);
    // printf("\nFKP unweighted shot noise P(k) expectation:   %e", 1./TotalZADEWeight);

    return 0;
}


int printSurveyDetails(){
    printf("\n\nSurvey type:  %s", surveyType);
    printf("\nChi limits:              %f to %f", LowerChiLimit, UpperChiLimit);
    printf("\nright ascension limits:  %f to %f", UpperRAlimit, LowerRAlimit);
    printf("\ndeclination limits:      %f to %f", UpperDecLimit, LowerDecLimit);
    printf("\nCell volume:                   %f.",        CellVolume); 
    printf("\n\nTotal volume:            %e", TotalVolume);
    printf("\nTotal surveyed volume:   %e", TotalSurveyedVolume);

    printf("\n\nfundamental x mode:  %f", kIntervalx);
    printf("\nfundamental y mode:  %f", kIntervaly);
    printf("\nfundamental z mode:  %f", kIntervalz);
    
    return 0;
}
